# About
Simple and efficient buffer switcher, using minimum of 2 keystrokes to get anywhere.
Whole plugin is just a single window and command to toggle that window.
This plugin is to meet my personal requirements, which doesn't include colors or icons, although I might still add more features.

# Screenshot
![w_14:21:18_Jun-04](https://github.com/user-attachments/assets/5eb9b122-21aa-4624-93fc-3ace0b58091c)

# Installation
Just use any package manager to install.
`setup()` function is not provided, instead see [configuration](#configuration)

# Usage
Single command, `:BuffersToggle`, toggles buffer window.
Every buffer is filtered using customizable predicate,
by default that is: `buflisted` option is true AND buffer has non-empty name.
In that window, only survived buffers are displayed.

From this window, any buffer can be opened using provided key next to it and buffers window is closed.

I recommend mapping `BuffersToggle` to single key for fastest navigation

# Configuration
Whole configuration is done via `vim.g.buffers_config` table which is checked every time buffers window opens,
so it can be tweaked, without reloading.
## Defaults
```lua
---@type buffers.Config
{
	width = 70, -- window width (longer lines are not yet handled)
	min_heigh = 6, -- minimum window height
	position = 'bottom_right', -- window position (can be 'bottom_right', 'top_right' or 'center')
	border = 'single', -- window border (accepts same values as vim.api.keyset.win_config.border)
	-- characters that can be bound to buffers
	chars = "qwertyuiopasdfghjklzxcvbnm1234567890",
	-- if non of the characters from `chars` is available use this list (see #internals for more info)
	backup_chars = "QWERTYUIOPASDFGHJKLZXCVBNM_-",
	-- called for every buffer, to determine if it should be listed in buffers window
	filter = function(bufnr)
		return vim.api.nvim_get_option_value("buflisted", { buf = bufnr })
			and vim.api.nvim_buf_get_name(bufnr) ~= ""
	end,
}
```

# Internals
Single character bound to each buffer is generated by simple algorithm called `get_buffer_char`.
```lua
local function get_buffer_char(name, buffer_table, chars)
	local char = name:sub(1, 1)
	local i = 2
	while buffer_table:get(char) or string.find(chars, char, 1, true) == nil do
		if i > #name then
			return nil
		end
		char = name:sub(i, i)
		i = i + 1
	end
	return char
end
```
This function returns first valid character from buffer's name.
character is valid if it's:
- not already used as a keymap
- found in `chars` string

Usage of this function is more interesting:
- For each buffer, first it's called with `chars` string from configuration.
- If nil is returned, than it's called with `backup_chars`.
- If that also fails, first available character from `chars` and `backup_chars` is used.

Accidental overlap of keymaps is pretty much impossible.

For actually mapping character to its buffers, `getcharstr` function, wrapped in `keytrans` is used.
Before commit `a541273`, I was using keymaps which where problematic!
[thanks to this comment](https://www.reddit.com/r/neovim/comments/1lhuqgp/comment/mzaa6u5/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)

# Contribution
PRs and Issues are welcome!

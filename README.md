# About
Simple and efficient buffer switcher, using minimum of 2 keystrokes to get anywhere.
Whole plugin is just a single window and command to toggle that window.
This plugin is to meet my personal requirements, which doesn't include colors or icons, although I might still add more features.

# Screenshot
![w_14:21:18_Jun-04](https://github.com/user-attachments/assets/5eb9b122-21aa-4624-93fc-3ace0b58091c)

# Installation
Just use any package manager to install.
`setup()` function is not provided, instead see [configuration](#configuration)

# Usage
Single command, `:BuffersToggle`, toggles buffer window.
In this window, every buffer is filtered using **currently** non-costumizable predicate,
that is: `buflisted` option is true AND buffer has non-empty name.

From this window, any buffer can be opened using provided key next to it and buffers window is closed.

I recommend mapping `BuffersToggle` to single key for fastest navigation

# Configuration
Whole configuration is done via `vim.g.buffers_config` table which is checked every time buffers window opens,
so it can be tweaked, without reloading.
## Defaults
```lua
---@type buffers.Config
{
	width = 70, -- window width (longer lines are not yet handled)
	min_heigh = 6, -- minimum window height
	position = 'bottom_right', -- window position (can be 'bottom_right', 'top_right' or 'center')
	border = 'single', -- window border (accepts same values as vim.api.keyset.win_config.border)
	-- characters that can be used as a keymap for switching buffers
	chars =  "qwertyuiopasdfghjklzxcvbnm1234567890",
	-- if non of the characters from `chars` is available use this list (see #internals for more info)
	backup_chars = "QWERTYUIOPASDFGHJKLZXCVBNM_-"
}
```

# Internals
Single character used as keymap for each buffer is generated by simple alghoritm called `get_buffer_char`.
```lua
local function get_buffer_char(name, buffer_table, chars)
	local char = name:sub(1, 1)
	local i = 2
	while buffer_table:get(char) or string.find(chars, char, 1, true) == nil do
		if i > #name then
			return nil
		end
		char = name:sub(i, i)
		i = i + 1
	end
	return char
end
```
This function returns first valid character from buffer's name.
character is valid if it's:
- not already used as a keymap
- found in `chars` string

Usage of this function is more interesting:
- For each buffer, first it's called with `chars` string from configuration.
- If nil is returned, than it's called with `backup_chars`.
- If that also fails, first available character from `chars` and `backup_chars` is used.

Accidental overlap of keymaps is pretty much impossible.

# Contribution
PRs and Issues are welcome!
